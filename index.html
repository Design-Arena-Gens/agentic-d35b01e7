<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Pagoda Garden</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">
        üèØ Voxel Pagoda Garden<br>
        üñ±Ô∏è Drag to rotate | Scroll to zoom
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 40, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 80, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Voxel geometry
        const voxelGeometry = new THREE.BoxGeometry(1, 1, 1);
        const voxels = new THREE.Group();
        scene.add(voxels);

        // Helper function to create voxel
        function createVoxel(x, y, z, color) {
            const material = new THREE.MeshLambertMaterial({ color });
            const voxel = new THREE.Mesh(voxelGeometry, material);
            voxel.position.set(x, y, z);
            voxel.castShadow = true;
            voxel.receiveShadow = true;
            return voxel;
        }

        // Helper to add multiple voxels
        function addVoxels(positions, color) {
            positions.forEach(([x, y, z]) => {
                voxels.add(createVoxel(x, y, z, color));
            });
        }

        // Ground layer - lush green grass with varied colors
        const grassColors = [0x2d5016, 0x3a6b1f, 0x4a7c2f, 0x567d34];
        for (let x = -60; x < 60; x++) {
            for (let z = -60; z < 60; z++) {
                const colorIndex = (Math.abs(x) + Math.abs(z)) % grassColors.length;
                voxels.add(createVoxel(x, 0, z, grassColors[colorIndex]));
            }
        }

        // PAGODA CONSTRUCTION

        // Pagoda base - stone foundation
        const stoneColor = 0x808080;
        const darkStone = 0x606060;

        // First level base (largest)
        for (let x = -8; x <= 8; x++) {
            for (let z = -8; z <= 8; z++) {
                for (let y = 1; y <= 2; y++) {
                    const color = (x + z) % 2 === 0 ? stoneColor : darkStone;
                    voxels.add(createVoxel(x, y, z, color));
                }
            }
        }

        // First level walls - red/burgundy
        const wallColor1 = 0x8B0000;
        const trimColor1 = 0xFFD700;

        for (let y = 3; y <= 8; y++) {
            // Outer walls
            for (let x = -7; x <= 7; x++) {
                voxels.add(createVoxel(x, y, -7, wallColor1));
                voxels.add(createVoxel(x, y, 7, wallColor1));
            }
            for (let z = -7; z <= 7; z++) {
                voxels.add(createVoxel(-7, y, z, wallColor1));
                voxels.add(createVoxel(7, y, z, wallColor1));
            }

            // Gold trim on corners
            if (y === 8) {
                for (let x = -7; x <= 7; x++) {
                    voxels.add(createVoxel(x, y, -7, trimColor1));
                    voxels.add(createVoxel(x, y, 7, trimColor1));
                }
                for (let z = -7; z <= 7; z++) {
                    voxels.add(createVoxel(-7, y, z, trimColor1));
                    voxels.add(createVoxel(7, y, z, trimColor1));
                }
            }
        }

        // First level roof - curved, dark tiles
        const roofColor1 = 0x2F1B1B;
        const roofTrim1 = 0xFF6347;

        for (let y = 9; y <= 12; y++) {
            const offset = 12 - y;
            for (let x = -7 - offset; x <= 7 + offset; x++) {
                voxels.add(createVoxel(x, y, -7 - offset, roofColor1));
                voxels.add(createVoxel(x, y, 7 + offset, roofColor1));
            }
            for (let z = -7 - offset; z <= 7 + offset; z++) {
                voxels.add(createVoxel(-7 - offset, y, z, roofColor1));
                voxels.add(createVoxel(7 + offset, y, z, roofColor1));
            }

            // Fill roof interior
            if (offset > 0) {
                for (let x = -7 - offset + 1; x < 7 + offset; x++) {
                    for (let z = -7 - offset + 1; z < 7 + offset; z++) {
                        voxels.add(createVoxel(x, y, z, roofColor1));
                    }
                }
            }
        }

        // Roof edge details
        for (let x = -11; x <= 11; x++) {
            voxels.add(createVoxel(x, 12, -11, roofTrim1));
            voxels.add(createVoxel(x, 12, 11, roofTrim1));
        }
        for (let z = -11; z <= 11; z++) {
            voxels.add(createVoxel(-11, 12, z, roofTrim1));
            voxels.add(createVoxel(11, 12, z, roofTrim1));
        }

        // Second level
        for (let x = -5; x <= 5; x++) {
            for (let z = -5; z <= 5; z++) {
                voxels.add(createVoxel(x, 13, z, stoneColor));
            }
        }

        const wallColor2 = 0xA52A2A;
        for (let y = 14; y <= 18; y++) {
            for (let x = -4; x <= 4; x++) {
                voxels.add(createVoxel(x, y, -4, wallColor2));
                voxels.add(createVoxel(x, y, 4, wallColor2));
            }
            for (let z = -4; z <= 4; z++) {
                voxels.add(createVoxel(-4, y, z, wallColor2));
                voxels.add(createVoxel(4, y, z, wallColor2));
            }

            if (y === 18) {
                for (let x = -4; x <= 4; x++) {
                    voxels.add(createVoxel(x, y, -4, trimColor1));
                    voxels.add(createVoxel(x, y, 4, trimColor1));
                }
                for (let z = -4; z <= 4; z++) {
                    voxels.add(createVoxel(-4, y, z, trimColor1));
                    voxels.add(createVoxel(4, y, z, trimColor1));
                }
            }
        }

        // Second level roof
        for (let y = 19; y <= 21; y++) {
            const offset = 21 - y;
            for (let x = -4 - offset; x <= 4 + offset; x++) {
                voxels.add(createVoxel(x, y, -4 - offset, roofColor1));
                voxels.add(createVoxel(x, y, 4 + offset, roofColor1));
            }
            for (let z = -4 - offset; z <= 4 + offset; z++) {
                voxels.add(createVoxel(-4 - offset, y, z, roofColor1));
                voxels.add(createVoxel(4 + offset, y, z, roofColor1));
            }
            if (offset > 0) {
                for (let x = -4 - offset + 1; x < 4 + offset; x++) {
                    for (let z = -4 - offset + 1; z < 4 + offset; z++) {
                        voxels.add(createVoxel(x, y, z, roofColor1));
                    }
                }
            }
        }

        // Third level (smaller)
        for (let x = -3; x <= 3; x++) {
            for (let z = -3; z <= 3; z++) {
                voxels.add(createVoxel(x, 22, z, stoneColor));
            }
        }

        const wallColor3 = 0xB22222;
        for (let y = 23; y <= 26; y++) {
            for (let x = -2; x <= 2; x++) {
                voxels.add(createVoxel(x, y, -2, wallColor3));
                voxels.add(createVoxel(x, y, 2, wallColor3));
            }
            for (let z = -2; z <= 2; z++) {
                voxels.add(createVoxel(-2, y, z, wallColor3));
                voxels.add(createVoxel(2, y, z, wallColor3));
            }
        }

        // Third level roof
        for (let y = 27; y <= 29; y++) {
            const offset = 29 - y;
            for (let x = -2 - offset; x <= 2 + offset; x++) {
                for (let z = -2 - offset; z <= 2 + offset; z++) {
                    voxels.add(createVoxel(x, y, z, roofColor1));
                }
            }
        }

        // Top spire
        const spireColor = 0xFFD700;
        for (let y = 30; y <= 35; y++) {
            const size = Math.max(0, 2 - Math.floor((y - 30) / 2));
            for (let x = -size; x <= size; x++) {
                for (let z = -size; z <= size; z++) {
                    voxels.add(createVoxel(x, y, z, spireColor));
                }
            }
        }

        // Top ornament
        voxels.add(createVoxel(0, 36, 0, 0xFF0000));
        voxels.add(createVoxel(0, 37, 0, 0xFF4500));

        // GARDEN ELEMENTS

        // Stone path - winding through garden
        const pathStone = 0xB8B8B8;
        const pathPositions = [
            [-15, 1, -15], [-14, 1, -15], [-13, 1, -14], [-12, 1, -13],
            [-11, 1, -12], [-10, 1, -11], [-9, 1, -10], [-8, 1, -9],
            [-15, 1, 15], [-14, 1, 15], [-13, 1, 14], [-12, 1, 13],
            [-11, 1, 12], [-10, 1, 11], [-9, 1, 10],
            [15, 1, -15], [14, 1, -15], [13, 1, -14], [12, 1, -13],
            [11, 1, -12], [10, 1, -11], [9, 1, -10],
            [15, 1, 15], [14, 1, 15], [13, 1, 14], [12, 1, 13],
            [11, 1, 12], [10, 1, 11], [9, 1, 10], [8, 1, 9]
        ];
        addVoxels(pathPositions, pathStone);

        // CHERRY BLOSSOM TREES (multiple, detailed)
        function createCherryTree(baseX, baseZ) {
            const trunkColor = 0x4A3020;
            const barkColor = 0x3D2817;

            // Trunk with texture
            for (let y = 1; y <= 12; y++) {
                voxels.add(createVoxel(baseX, y, baseZ, y % 2 === 0 ? trunkColor : barkColor));
                if (y > 6) {
                    voxels.add(createVoxel(baseX + 1, y, baseZ, trunkColor));
                    voxels.add(createVoxel(baseX, y, baseZ + 1, trunkColor));
                }
            }

            // Branches
            const branches = [
                [baseX + 2, 10, baseZ], [baseX - 2, 11, baseZ],
                [baseX, 10, baseZ + 2], [baseX, 11, baseZ - 2],
                [baseX + 3, 9, baseZ + 1], [baseX - 3, 10, baseZ - 1]
            ];
            branches.forEach(([x, y, z]) => {
                voxels.add(createVoxel(x, y, z, trunkColor));
            });

            // Cherry blossoms - pink petals
            const petalColors = [0xFF69B4, 0xFFB6C1, 0xFF1493, 0xFFC0CB, 0xFFE4E1];

            for (let x = baseX - 5; x <= baseX + 5; x++) {
                for (let z = baseZ - 5; z <= baseZ + 5; z++) {
                    for (let y = 11; y <= 16; y++) {
                        const dx = x - baseX;
                        const dz = z - baseZ;
                        const dy = y - 13;
                        const dist = Math.sqrt(dx * dx + dz * dz + dy * dy);

                        if (dist < 5 && Math.random() > 0.3) {
                            const colorIndex = Math.floor(Math.random() * petalColors.length);
                            voxels.add(createVoxel(x, y, z, petalColors[colorIndex]));
                        }
                    }
                }
            }

            // Floating petals below tree
            for (let i = 0; i < 15; i++) {
                const x = baseX + (Math.random() - 0.5) * 8;
                const z = baseZ + (Math.random() - 0.5) * 8;
                const y = 1 + Math.random() * 3;
                const colorIndex = Math.floor(Math.random() * petalColors.length);
                voxels.add(createVoxel(Math.floor(x), Math.floor(y), Math.floor(z), petalColors[colorIndex]));
            }
        }

        // Place multiple cherry trees
        createCherryTree(-25, -25);
        createCherryTree(25, -25);
        createCherryTree(-25, 25);
        createCherryTree(30, 30);

        // REGULAR TREES (pine/cypress style)
        function createPineTree(baseX, baseZ) {
            const trunkColor = 0x5D4037;
            const leafColors = [0x1B5E20, 0x2E7D32, 0x388E3C, 0x43A047];

            // Trunk
            for (let y = 1; y <= 15; y++) {
                voxels.add(createVoxel(baseX, y, baseZ, trunkColor));
            }

            // Conical foliage
            for (let y = 8; y <= 18; y++) {
                const radius = Math.max(1, 6 - Math.floor((y - 8) / 2));
                for (let x = baseX - radius; x <= baseX + radius; x++) {
                    for (let z = baseZ - radius; z <= baseZ + radius; z++) {
                        const dx = x - baseX;
                        const dz = z - baseZ;
                        if (dx * dx + dz * dz <= radius * radius && Math.random() > 0.2) {
                            const colorIndex = Math.floor(Math.random() * leafColors.length);
                            voxels.add(createVoxel(x, y, z, leafColors[colorIndex]));
                        }
                    }
                }
            }
        }

        createPineTree(-35, 10);
        createPineTree(35, -10);
        createPineTree(-30, 35);
        createPineTree(40, 15);
        createPineTree(-40, -15);

        // DECORATIVE SHRUBS
        function createShrub(baseX, baseZ) {
            const shrubColors = [0x2E7D32, 0x388E3C, 0x4CAF50];
            for (let y = 1; y <= 3; y++) {
                for (let x = baseX - 1; x <= baseX + 1; x++) {
                    for (let z = baseZ - 1; z <= baseZ + 1; z++) {
                        if (Math.random() > 0.3) {
                            const colorIndex = Math.floor(Math.random() * shrubColors.length);
                            voxels.add(createVoxel(x, y, z, shrubColors[colorIndex]));
                        }
                    }
                }
            }
        }

        // Place shrubs around the garden
        for (let i = 0; i < 20; i++) {
            const angle = (i / 20) * Math.PI * 2;
            const radius = 18 + Math.random() * 8;
            const x = Math.floor(Math.cos(angle) * radius);
            const z = Math.floor(Math.sin(angle) * radius);
            createShrub(x, z);
        }

        // STONE LANTERNS (traditional Japanese garden)
        function createLantern(baseX, baseZ) {
            const stoneColor = 0x696969;
            const lightColor = 0xFFF8DC;

            // Base
            for (let y = 1; y <= 2; y++) {
                voxels.add(createVoxel(baseX, y, baseZ, stoneColor));
                voxels.add(createVoxel(baseX + 1, y, baseZ, stoneColor));
                voxels.add(createVoxel(baseX, y, baseZ + 1, stoneColor));
                voxels.add(createVoxel(baseX + 1, y, baseZ + 1, stoneColor));
            }

            // Post
            for (let y = 3; y <= 6; y++) {
                voxels.add(createVoxel(baseX, y, baseZ, stoneColor));
            }

            // Light box
            for (let y = 7; y <= 8; y++) {
                voxels.add(createVoxel(baseX, y, baseZ, lightColor));
                voxels.add(createVoxel(baseX + 1, y, baseZ, stoneColor));
                voxels.add(createVoxel(baseX - 1, y, baseZ, stoneColor));
                voxels.add(createVoxel(baseX, y, baseZ + 1, stoneColor));
                voxels.add(createVoxel(baseX, y, baseZ - 1, stoneColor));
            }

            // Roof
            voxels.add(createVoxel(baseX, 9, baseZ, stoneColor));
            voxels.add(createVoxel(baseX + 1, 9, baseZ, stoneColor));
            voxels.add(createVoxel(baseX - 1, 9, baseZ, stoneColor));
            voxels.add(createVoxel(baseX, 9, baseZ + 1, stoneColor));
            voxels.add(createVoxel(baseX, 9, baseZ - 1, stoneColor));
            voxels.add(createVoxel(baseX, 10, baseZ, stoneColor));
        }

        createLantern(-18, -18);
        createLantern(18, -18);
        createLantern(-18, 18);
        createLantern(18, 18);

        // DECORATIVE ROCKS
        const rockColor = 0x555555;
        const rockPositions = [
            [-20, 1, 0], [-21, 1, 0], [-20, 1, 1],
            [20, 1, 0], [21, 1, 0], [20, 1, 1], [21, 1, 1],
            [0, 1, -20], [1, 1, -20], [0, 1, -21],
            [0, 1, 20], [1, 1, 20], [0, 1, 21], [1, 1, 21],
            [-15, 1, -5], [-15, 1, -6], [-16, 1, -5],
            [15, 1, 5], [15, 1, 6], [16, 1, 5]
        ];
        addVoxels(rockPositions, rockColor);

        // FLOWERS (colorful accents)
        const flowerColors = [0xFF0000, 0xFF69B4, 0xFFFF00, 0xFF8C00, 0x9370DB, 0xFF1493];
        for (let i = 0; i < 100; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 12 + Math.random() * 25;
            const x = Math.floor(Math.cos(angle) * radius);
            const z = Math.floor(Math.sin(angle) * radius);

            // Avoid placing on pagoda
            if (Math.abs(x) > 10 || Math.abs(z) > 10) {
                const colorIndex = Math.floor(Math.random() * flowerColors.length);
                voxels.add(createVoxel(x, 1, z, 0x0F6F0F)); // Stem
                voxels.add(createVoxel(x, 2, z, flowerColors[colorIndex]));
            }
        }

        // POND with bridge
        const waterColor = 0x4169E1;
        const darkWater = 0x1E3A8A;

        for (let x = -45; x <= -30; x++) {
            for (let z = -10; z <= 5; z++) {
                const color = (x + z) % 2 === 0 ? waterColor : darkWater;
                voxels.add(createVoxel(x, 1, z, color));
            }
        }

        // Bridge over pond
        const bridgeWood = 0x8B4513;
        const bridgeRail = 0xA0522D;
        for (let x = -45; x <= -30; x++) {
            voxels.add(createVoxel(x, 2, -2, bridgeWood));
            voxels.add(createVoxel(x, 2, -1, bridgeWood));
            voxels.add(createVoxel(x, 2, 0, bridgeWood));

            // Rails
            if (x % 3 === 0) {
                voxels.add(createVoxel(x, 3, -2, bridgeRail));
                voxels.add(createVoxel(x, 3, 0, bridgeRail));
                voxels.add(createVoxel(x, 4, -2, bridgeRail));
                voxels.add(createVoxel(x, 4, 0, bridgeRail));
            }
        }

        // Lily pads
        const lilyPad = 0x228B22;
        const lilyFlower = 0xFFFFE0;
        const lilyPositions = [
            [-43, 1, -8], [-40, 1, -6], [-38, 1, -4], [-35, 1, -7],
            [-42, 1, 3], [-39, 1, 4], [-36, 1, 2], [-33, 1, 3]
        ];
        lilyPositions.forEach(([x, y, z]) => {
            voxels.add(createVoxel(x, y, z, lilyPad));
            voxels.add(createVoxel(x, y + 1, z, lilyFlower));
        });

        // FENCE around garden perimeter
        const fenceWood = 0x654321;
        for (let x = -50; x <= 50; x += 3) {
            for (let y = 1; y <= 3; y++) {
                voxels.add(createVoxel(x, y, -50, fenceWood));
                voxels.add(createVoxel(x, y, 50, fenceWood));
            }
        }
        for (let z = -50; z <= 50; z += 3) {
            for (let y = 1; y <= 3; y++) {
                voxels.add(createVoxel(-50, y, z, fenceWood));
                voxels.add(createVoxel(50, y, z, fenceWood));
            }
        }

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Gentle rotation of the scene
            voxels.rotation.y += 0.0005;

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
